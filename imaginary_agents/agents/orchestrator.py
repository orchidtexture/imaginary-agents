import os
import instructor
import openai
from typing import List, Dict, Any, Union
from pydantic import Field, create_model
from atomic_agents.lib.base.base_io_schema import BaseIOSchema
from atomic_agents.lib.components.system_prompt_generator import (
    SystemPromptGenerator
)
from atomic_agents.agents.base_agent import (
    BaseAgent,
    BaseAgentConfig
)
from dotenv import load_dotenv

load_dotenv()

DEEPSEEK_API_URL = os.getenv("DEEPSEEK_API_URL")


########################
# INPUT/OUTPUT SCHEMAS #
########################
class OrchestratorInputSchema(BaseIOSchema):
    """
        Input schema for the Orchestrator Agent.
        Contains the user's message to be processed.
    """

    chat_message: str = Field(
        ...,
        description="The user's input message to be analyzed and responded to."
    )


class FinalAnswerSchema(BaseIOSchema):
    """Schema for the final answer generated by the Orchestrator Agent."""

    final_answer: str = Field(
        ...,
        description="The final answer generated based on the tool output and user query."
    )


class OrchestratorAgent(BaseAgent):
    """
        An Agent that receives a user's message and determines which tool to use.
        It can use tools dinamically.
    """

    input_schema = OrchestratorInputSchema

    def __init__(
        self,
        available_tools: List[Dict[str, Any]],  # A list of tools assigned by user
        llm_provider: str,
        model: str,
        api_key: str = None,
    ):
        """
        Initialize the OrchestratorAgent with a list of available tools.

        Args:
            available_tools: List of tools assigned to the agent
            api_key: OpenAI API key (defaults to env var)
            llm_provider: LLM provider to use
            model: OpenAI model to use
        """

        # Extract tool names and input schemas from available_tools
        tool_names = []
        tool_docs = {}
        tool_input_schemas = []

        for tool_info in available_tools:
            # Get the tool name - either from "name" key or from the class name
            name = tool_info["tool"].__name__
            tool_names.append(name)

            # Get the docstring from the tool class
            doc = tool_info["tool"].__doc__
            if doc:
                # Clean up the docstring (remove extra whitespace)
                doc = ' '.join(
                    [line.strip() for line in doc.split('\n') if line.strip()]
                )
            else:
                doc = f"Tool for {name} operations"

            tool_docs[name] = doc

            # Get the input schema
            tool_input_schemas.append(tool_info["input_schema"])

        # Create a Union type for tool parameters
        # For Python's typing system, we need to handle the Union differently
        # based on number of schemas
        if len(tool_input_schemas) > 1:
            # Create a Union of all input schemas
            tool_parameters_type = Union[tuple(tool_input_schemas)]
        else:
            # If there's only one schema, use it directly
            tool_parameters_type = tool_input_schemas[0]

        # Create description string listing all available tools
        print(tool_names)
        tools_desc = ", ".join([f"'{name}'" for name in tool_names])

        # TODO: Create outputSchema dinamically
        # Create Agent configuration dinamically
        OrchestratorOutputSchema = create_model(
            'OrchestratorAgentOutputSchema',
            __base__=BaseIOSchema,
            __doc__="""
                Combined output schema for the Orchestrator Agent.
                Contains the tool/s to use and its parameters.
            """,
            tool=(
                str,
                Field(..., description=f"The tool to use: {tools_desc}")
            ),
            tool_parameters=(
                tool_parameters_type,  # Using Union of input schemas
                Field(..., description="The parameters for the selected tool")
            ),
        )

        if llm_provider == "deepseek":  # TODO: make multi provider dinamically
            # Create Deepseek client
            client = instructor.from_openai(
                openai.OpenAI(
                    api_key=api_key,
                    base_url=DEEPSEEK_API_URL,
                ),
                mode=instructor.Mode.MD_JSON
            )
        else:
            # Create OpenAI client
            client = instructor.from_openai(openai.OpenAI(api_key=api_key))

        tools_usage = [
            f"Use the {tool} tool if the request matches its description: {description}"
            for tool, description in tool_docs.items()
            ]

        background = [
            f"You are an Orchestrator Agent that decides between using: {
                tools_desc
            } tools based on user input."
        ]
        background.extend(tools_usage)
        output_instructions = [
            f"Analyze the input to determine whether it requires: {tools_desc}.",
            "When uncertain, don't choose any tool.",
            "Format the output using the appropriate schema.",
        ]

        print("################################")
        print("########## BACKGROUND ###########")
        print("################################")
        print(background)

        # Create agent config
        config = BaseAgentConfig(
            client=client,
            model=model,
            system_prompt_generator=SystemPromptGenerator(
                background=background,
                output_instructions=output_instructions
            ),
            input_schema=OrchestratorInputSchema,
            output_schema=OrchestratorOutputSchema
        )

        # Setup agent configuration
        super().__init__(config)
